\label{Chapter3}

\chapter{A tool for Ethereum analytics}
\section{Tool architecture}
In this section we will describe how this tool works. This tool is build for create a custom view of either the Ethereum blockchain or the Bitcoin blockchain.
\newline 
Since we do not use Bitcoin blockchain, we will describe only how the Ethereum part works. We said the the view is \textit{custom} because this tool allows the user to extract whatever he needs from the blockchain, such as:
\begin{itemize}
    \item Blocks information, e.g. block number, block hash;
    \item Transactions information, e.g. transaction hash, sender, receiver, created contract (if exists);
    \item Contract internal transactions information, e.g. transaction hash, sender, receiver, father transaction hash (the transaction that calls the defined contract)
\end{itemize}

Furthermore, the view \textit{customization} is possible because our tool is able to retrieve \textbf{external data} (for external we mean data not stored directly inside blockchain) and combine it with blockchain's internal data. This external data could be of any nature, e.g. exchange rates, ICOs data, \textit{etc...}.

The image in the next page shows how out tool works. %Cambiare immagine, aggiungere anche i dati esterni
\begin{center}
    \[
        \includegraphics[
            trim=1cm 3cm 1cm 1cm,
            width=0.85\columnwidth,]{architecture_total.png}
    \]
\end{center}
As you can see, in order to retrieve blockchain data, our tool makes a request through Web3J (described in \ref{web3j}), which in turn makes a request directly to the Ethereum client, in our case Parity (described in \ref{parity}). This requests are made using the JSON-RPC protocol (described in \ref{jsonrpc}). 

When Parity returns the wanted result, Web3J serialize it into a collection of objects, then returns them to our tool. Since these classes do not contains all information, we decided to wrap them in another classes, retrieving all missing information, i.e. contract internal trasactions.

In the next subsections, we briefly describe how Parity, Web3J and JSON RPC work. Then, in the next sections, we show some view examples, using \textit{MongoDB} as DBMS.

\subsection{Parity}
\label{parity}
\href{https://www.parity.io/}{Parity} \cite{authors2017ethereum} is an Ethereum client, written from the ground-up for correctness-verifiability, modularisation, low-footprint and high-performance. \newline
To this end it utilises the Rust language, a hybrid imperative/OO/functional language with an emphasis on efficiency. 
\newline
Parity comes with an extensive, in-built Ethereum Wallet and DApp environment. It includes:
\begin{itemize}
    \item Account, address-book and multi-sig management.
    \item Key creation, importing and exporting.
    \item Web3 Ðapp browser.
    \item Hardware and electronic cold-wallet support.
    \item Name registry support.
    \item Contract development, deployment and interaction environment.
\end{itemize}

\subsection{Web3J}
\label{web3j}
\href{https://web3j.io/}{Web3J} is a highly modular, reactive, type safe Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network. This allows to work with the Ethereum blockchain, without the additional overhead of having to write an integration code for the platform.

Web3J is capable to connect to a local blockchain, downloaded using Parity, \href{https://github.com/ethereum/go-ethereum/wiki/geth}{Geth} or another Ethereum client, or a remote one, like \href{https://infura.io}{Infura}.
In order to retrieve blockchain data, Web3J uses a protocol called JSON-RPC, which will be described in section \ref{jsonrpc}. 

\subsection{JSON-RPC}
\label{jsonrpc}
JSON-RPC \cite{json2012json} is a remote procedure call protocol encoded in JSON. It is a very simple protocol (and very similar to XML-RPC), defining only a few data types and commands. JSON-RPC allows for notifications (data sent to the server that does not require a response) and for multiple calls to be sent to the server which may be answered out of order.

JSON-RPC works by sending a request to a server implementing this protocol. The client in that case is typically software intending to call a single method of a remote system. Multiple input parameters can be passed to the remote method as an array or object, whereas the method itself can return multiple output data as well. (This depends on the implemented version).

All transfer types are single objects, serialized using JSON. A request is a call to a specific method provided by a remote system. It must contain three certain properties:
\begin{itemize}
    \item \textit{Method}: A String with the name of the method to be invoked;
    \item \textit{Params}: An Object or Array of values to be passed as parameters to the defined method;
    \item \textit{Id}: A value of any type used to match the response with the request that it is replying to.
\end{itemize}

The receiver of the request must reply with a valid response to all received requests. A response must contain the following properties:
\begin{itemize}
    \item \textit{Result}: The data returned by the invoked method. If an error occurred while invoking the method, this value must be null;
    \item \textit{Error}: A specified error code if there was an error invoking the method, otherwise null;
    \item \textit{Id}: The id of the request it is responding to.
\end{itemize}
Since there are situations where no response is needed or even desired, notifications were introduced. A notification is similar to a request except for the id, which is not needed because no response will be returned. In this case the id property should be omitted (Version 2.0) or be null (Version 1.0).
\subsubsection{Examples}
In this subsection, we will show one example of \textit{Request and Response} and one of \textit{Notification} using JSON-RPC version 2.0.
\newline
Request and response:
\begin{lstlisting}[language=json]
Request
{
    "jsonrpc": "2.0", 
    "method": "subtract", 
    "params": {
                "minuend": 42, 
                "subtrahend": 23
              },
    "id": 3
}
Response 
{
    "jsonrpc": "2.0", 
    "result": 19, 
    "id": 3
}
\end{lstlisting}
Notification, with no response
\begin{lstlisting}[language=json]
{
    "jsonrpc": "2.0",
    "method": "update",
    "params": [1,2,3,4,5]
}
\end{lstlisting}
\section{Case study: a basic view of the blockchain}
This view contains data about all transactions (and, contract internal transactions) that has been done inside Ethereum blockchain. The fields in this view are the following:
\begin{itemize}
    \item \textit{\textbf{txHash}}: transaction hash;
    \item \textit{\textbf{blockHeight}}: block number of the block that contains this transaction;
    \item \textit{\textbf{txIndex}}: transaction progressive number inside its block;
    \item \textit{\textbf{date}}: the date when block is mined;
    \item \textit{\textbf{from}}: transaction sender (the address of who is transferring money or creating a contract);
    \item \textit{\textbf{to}}: transaction receiver (the address of who is receiving money, this field is empty if this transaction creates a contract);
    \item \textit{\textbf{value}}: how much (in ETH) is transferred;
    \item \textit{\textbf{creates}}: the address of the newly created contract (empty if this transaction does not create a contract);
    \item \textit{\textbf{internalTransactions}}: contains all the internal transactions generated by this transaction, it's a list of objects containing the following fields:
        \subitem \textit{\textbf{parentTxHash}}: hash of the father transaction (the transaction that generates this one);
        \subitem \textit{\textbf{txType}}: internal transaction type (call, suicide, create);
        \subitem \textit{\textbf{from}}: internal transaction sender;
        \subitem \textit{\textbf{to}}: internal transaction receiver;
        \subitem \textit{\textbf{value}}: how much (in ETH) in transferred.
\end{itemize}
Here's the code snippet used to create this view:
\begin{lstlisting}[language=Scala]
    val blockchain = BlockchainLib.getEthereumBlockchain("http://localhost:8545")
      val mongo = new DatabaseSettings("myDatabase")
      val myBlockchain = new Collection("myBlockchain", mongo)

      blockchain.foreach(block => {
        if(block.number % 1000 == 0){
          println("Current block ->" + block.number)
        }
        val date = new Date(block.timeStamp.longValue()*1000)
        block.transactions.foreach(tx => {
          val internalTransactions = block.internalTransactions.filter(itx => itx.parentTxHash.equals(tx.hash))
          val creates = if(tx.creates == null) "" else tx.creates
          val to = if(tx.to == null) "" else tx.to
          val list = List(
            ("txHash", tx.hash),
            ("blockHeight", tx.blockNumber.toString()),
            ("txIndex", tx.transactionIndex),
            ("date", date),
            ("from", tx.from),
            ("to", to),
            ("value", tx.value.doubleValue()),
            ("creates", creates),
            ("internalTransactions", internalTransactions)
          )
          myBlockchain.append(list)})
\end{lstlisting}
\subsection{Querying view in MongoDB}
\subsubsection{Ethereum per day}
This query calculates the total amount of Ether transacted and its mean per day.
\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
db.myBlockchain.aggregate([
   { $group : {
       _id: {
           year : { $year : "$date" },
           month : { $month : "$date" },
           day : { $dayOfMonth : "$date" },
       },
       sumValues: { $sum: "$value"},
       avgValues: { $avg: "$value"}
   }},
   { $sort : { avgValues : 1, sumValues: 1}}
]);
\end{verbatim}
\end{varwidth}
\end{center}
\subsubsection{Contract creation}
This query search all transactions that create a smart contract. It returns only the created smart contract address. 
\begin{center}
\begin{varwidth}{\linewidth}
\begin{verbatim}
db.myBlockchain.find({
   creates: {$ne: ""}
},{
   _id: 0, creates: 1
});

\end{verbatim}
\end{varwidth}
\end{center}
\section{Case study: Exchange rates}
\label{exchangerates}
This view contains data about all transactions, combined with the Ethereum conversion price in USD in that specific day. 
The fields in this view are the following:
\begin{itemize}
    \item \textit{\textbf{txHash}}: transaction hash;
    \item \textit{\textbf{blockHeight}}: block number of the block that contains this transaction;
    \item \textit{\textbf{txIndex}}: transaction progressive number inside its block;
    \item \textit{\textbf{date}}: the date when block is mined;
    \item \textit{\textbf{from}}: transaction sender (the address of who is transferring money or creating a contract);
    \item \textit{\textbf{to}}: transaction receiver (the address of who is receiving money, this field is empty if this transaction creates a contract);
    \item \textit{\textbf{value}}: how much (in ETH) is transferred;
    \item \textit{\textbf{creates}}: the address of the newly created contract (empty if this transaction does not create a contract);
    \item \textit{\textbf{rate}}: Ethereum-USD conversion price.
\end{itemize}
Here's the code snippet used to create this view:
\begin{lstlisting}[language=Scala]
    val blockchain = BlockchainLib.getEthereumBlockchain("http://localhost:8545")
    val mongo = new DatabaseSettings("myDatabase")
    val weiIntoEth = BigInt("1000000000000000000")
    val txWithRates = new Collection("txWithRates", mongo)
    val format = new SimpleDateFormat("yyyy-MM-dd")
    val priceHistorical = PriceHistorical.getPriceHistorical()

    blockchain.foreach(block => {
      if(block.number % 1000 == 0){
        println("Current block ->" + block.number)
      }
      val date = new Date(block.timeStamp.longValue()*1000)
      val dateFormatted = format.format(date)
      block.transactions.foreach(tx => {
        val creates = if(tx.creates == null) "" else tx.creates
        val to = if(tx.to == null) "" else tx.to
        val list = List(
          ("txHash", tx.hash),
          ("blockHeight", tx.blockNumber.toString()),
          ("txIndex", tx.transactionIndex),
          ("date", date),
          ("from", tx.from),
          ("to", to),
          ("value", tx.value.doubleValue()/weiIntoEth.doubleValue()),
          ("creates", creates),
          ("rate", if(block.timeStamp.longValue() < 1438905600) 0 else priceHistorical.price_usd(dateFormatted))
        )
        txWithRates.append(list)})
\end{lstlisting}
If we combine this view with the previous one, which contains the amount of ether transacted per day, we can plot a graphic containing the volume per day for Ethereum. In the next page, we show the extracted graphic.
\begin{center}
    \[
        \includegraphics[trim=0 0 0 0.5cm, clip, scale=0.2]{price_daily.png}
    \]
\end{center}
If we set the query in order to retrieve the weekly and monthly mean of this information, we have the following graphics:
\begin{center}
    \[
        \includegraphics[trim=0 0 0 0.5cm, clip, width=0.5\columnwidth]{price_weekly.png}
        \includegraphics[trim=0 0 0 0.5cm, clip, width=0.5\columnwidth]{price_monthly.png}
    \]
\end{center}
\section{Case study: Levenshtein Distance between contract}
In information theory, Linguistics and computer science, the Levenshtein distance is a string metric for measuring the difference between two sequences.
In order to calculate Levenshtein distance between contracs EVM, first of all we create a view in MongoDB or SQL that contains only useful information retrieved from blockchain.
The useful fields are only two:
\begin{itemize}
    \item \textit{\textbf{contractAddress}}: The contract address inside blockchain (to uniquely identify a contract inside view);
    \item \textit{\textbf{contractCode}}: The contract EVM code
\end{itemize}
The distance calculation is done using this formula:
\begin{center}
$\operatorname{lev}_{a,b}(i,j) = 
\begin{cases}
  \max(i,j) & \text{ if} \min(i,j)=0, \\
  \min \begin{cases}
      \operatorname{lev}_{a,b}(i-1,j) + 1 \\
      \operatorname{lev}_{a,b}(i,j-1) + 1 \\
      \operatorname{lev}_{a,b}(i-1,j-1) + 1_{(a_i \neq b_j)}
   \end{cases} & \text{ otherwise.}
\end{cases}
$
\end{center}


\section{Implementation}
In this section we will explain in details the implementation of the tool, built to retrieve blockchain data and other external data and combine them.

This tool is written in Scala Programming Language and built with Scala Build Tool (SBT). Scala has been chosen because, since it's compiled in bytecode that runs on Java Virtual Machine (JVM), it can be combined with Java external libraries without any problem. \newline
Thanks to this property, it was possible to use Web3J (explained in \ref{web3j}) library to retrieve blockchain data. It is a Java and Android library for working with Smart Contracts and integrating with clients (nodes) on the Ethereum network.

The core class, used to access both \textit{Ethereum} and \textit{Bitcoin} blockchain is \texttt{BlockchainLib}. It has two methods:
\begin{itemize}
    \item \texttt{getBitcoinBlockchain(settings: BitcoinSettings)}
    \item \texttt{getEthereumBlockchain(url: String)}
\end{itemize}
Since for this thesis we used only \texttt{getEthereumBlockchain}, we will describe only this class. 
\newline
The \texttt{getEthereumBlockchain} method takes one parameter that is the url where the blockchain is stored.
For example, if you are using Parity locally, the url should be like \texttt{http://localhost:8545}, since the \texttt{8545} port is the default port where Parity listens to JSON-RPC requests.

This method returns an istance of \texttt{EthereumBlockchain} which extends a \texttt{Traversable}, so it can be looped with a simple \texttt{foreach}, setting first the following parameters:
\begin{itemize}
    \item \textit{startBlock}: the block from which to start. It is modifiable with the \texttt{setStart} method. If not setted, the default is 0;
    \item \textit{endBlock}: the block from which to end. It is modifiable with the \texttt{setEnd} method. If not setted, the default is the last block;
    \item \textit{step}: the interval between each block visited. It is modifiable with the \texttt{setStep} method. If not setted, the default is 1.
\end{itemize}

This \texttt{foreach} loops over all requested block. Each block is an instance of the \texttt{EthereumBlock} class. An \texttt{EthereumBlock} object is retrieved from an \texttt{EthBlock.Block} object of the \textit{Web3J} library, retrieved calling the \texttt{Web3J.getBlockByNumber} method. This \textit{Web3J}'s method does internally a JSON-RPC request to the \textit{getBlockByNumber} method, directly to Parity, at the previously defined url.
\newline
The difference between the \texttt{EthereumBlock} object and the \texttt{EthBlock.Block} object is that the first one contains also the internal transactions information, not normally returned using an implemented method in \textit{Web3J}. \newline
In order to retrieve all information about Contract Internal Transaction, we have to do anther JSON-RPC request calling the \textit{trace\_block} method. This request allows to see all the transactions and internal transactions contained in this block. From this request, we extract only the internal transactions, filtering the normal transactions, already known.
\newline
Each \texttt{EthereumBlock} object contains the following information:
\begin{itemize}
    \item \textit{number}: block number inside blockchain;
    \item \textit{hash}: block hash;
    \item \textit{parentHash}: hash of the parent block;
    \item \textit{miner}: address of the account that mined this block;
    \item \textit{size}: size of block in bytes;
    \item \textit{timeStamp}: the unix timestamp for when the block was collated;
    \item \textit{transactions}: Array of transaction objects (this data structure will be described below);
    \item \textit{internalTransactions}: Array of contract transaction objects (this data structure will be described blow).
\end{itemize}

The \textit{transaction} field is a List of \texttt{EthereumTransaction} objects. These objects are created using a factory method that takes as input a object of \texttt{EthBlock.TransactionObject} \textit{Web3J} class. 
\newline
Each \texttt{EthereumTransaction} object contains the following information:
\begin{itemize}
    \item \textit{hash}: transaction hash;
    \item \textit{blockHash}: hash of the block that contains this transaction;
    \item \textit{transactionIndex}: index of the transaction inside its block;
    \item \textit{from}: transaction sender;
    \item \textit{to}: transaction receiver;
    \item \textit{value}: value transferred in this transaction in Wei;
    \item \textit{gasPrice}: gas price provided by the sender in Wei;
    \item \textit{gas}: gas provided by the sender;
    \item \textit{input}: the data send along with the transaction;
    \item \textit{creates}: creates contract hash. This field is not null if and only if this transaction creates a contract, which address is displayed here;
\end{itemize}
The \textit{internalTransactions} field is a List of \texttt{EthereumInternalTransaction} objects. These objects are created unmarshalling the result of the  \textit{trace\_block} JSON-RPC request. \newline
Each \texttt{EthereumInternalTransaction} object contains the following information:
\begin{itemize}
    \item \textit{parentTxHash}: hash of the parent transaction;
    \item \textit{txType}: transaction type (create, suicide, call);
    \item \textit{from}: transaction sender;
    \item \textit{to}: transaction receiver;
    \item \textit{value}: value transferred in this transaction in Wei.
\end{itemize}

These classes envelop all the Ethereum Blockchain's useful data. In order to retrieve external data (e.g. ICO data), we have to create one new class inside the \texttt{custom} package.
\newline
Let's consider the section \ref{exchangerates} as an example. In order to retrieve the exchange rate information, we created a new class called \texttt{custom.PriceHistorical} with one method, called \texttt{getPrice} which takes one argument as input that is the date timestamp, and returns the ETH/USD exchange rate in that timestamp.

When all the data is prepared to be gathered, you must choose what kind of database you will use. This tool supports both SQL (MySQL, PostgreSQL) and NoSQL (MongoDB) databases.
If you want to use a \textbf{SQL} database, you have to use our \texttt{db} package, designed to be used in these cases. More precisely, you have to instantiate an object of the \texttt{Table} class, that is a table in the SQL database. 
\newline
Here's an exhaustive example:
\begin{lstlisting}[language=Scala]
    import tcs.db.sql.Table
    import tcs.db.{DatabaseSettings, PostgreSQL}
    val blockTable = new Table(
      sql"""
          SQL COMMAND TO CREATE TABLE
         """,
      sql"""
           SQL COMMAND TO INSERT ELEMENT IN TABLE
         """,
      new DatabaseSettings(dbName, PostgreSQL)
    )
\end{lstlisting}
If you want to use a \textbf{NoSQL} database, you have to use our \texttt{mongo} and \texttt{db} packages, designed to be used in these cases. More precisely, you have to instantiate an object of the \texttt{Collection} class, then call this \texttt{append} method to add elements inside the collection. 
\newline
Here's an example:
\begin{lstlisting}[language=Scala]
    import mongo.Collection
    import db.{DatabaseSettings, MongoDB}
    val collection = new Collection(
        "collectionName", 
        new DatabaseSettings("dbName", MongoDB)
    )
    //Data Gathering
    collection.append(gatheredData)
\end{lstlisting}

\section{Related works}
This work is based on a previous work. We first developed a tool for Ethereum blockchain analytics, improving an existing tool \cite{bartoletti2017generalbit,bartoletti2017generalblock}, which is intended to analyse Bitcoin blockchain.